import numpy as np
import control

# ==========================================
# 1. 定义物理参数 (根据 xacro 提取)
# ==========================================
M = 1.0     # 底盘（两个轮子）质量 (0.5kg * 2)
m = 2.0     # 车身（不含轮子）质量 (mass=2.0)
l = 0.305    # 轮轴到重心距离 (wheel_joint z偏移绝对值 = height*5 = 0.061*2)
g = 9.81    # 重力加速度
I = 0.04229  # 车身绕 Y 轴转动惯量 (iyy)
b = 0.02     # 摩擦系数 (从 xacro damping=0.01 估算，双轮合计)

# ==========================================
# 2. 构建状态空间矩阵 A 和 B
# ==========================================
# 辅助变量
Mt = M + m
Jt = I + m * (l**2)
delta = Mt * Jt - (m*l)**2

# 状态向量 x = [p, v, theta, omega]^T
# 矩阵 A (4x4)
A = np.array([
    [0, 1, 0, 0],
    [0, -(Jt*b)/delta, -(m**2 * g * l**2)/delta, 0],
    [0, 0, 0, 1],
    [0, -(m*l*b)/delta, (Mt*m*g*l)/delta, 0]
])

# 矩阵 B (4x1)
B = np.array([
    [0],
    [Jt/delta],      # 对位移的加速度贡献是正的
    [0],
    [-(m*l)/delta]   # <--- 修改为负值！！对角度的加速度贡献是负的（车前冲，杆后倒）
])

# ==========================================
# 3. 定义 Q 和 R 权重 (布莱森法则)
# ==========================================
# Q 是对角阵，分别对应 [位置, 速度, 角度, 角速度]
# 增大对应的数值意味着你更在意该项的偏差
Q = np.diag([
    200,    # 位置权重 (让车尽量不乱跑)
    5,      # 速度权重
    700,    # 角度权重 (这是站稳的核心，通常设最大)
    5      # 角速度权重 (提供阻尼，防止震荡)
])

# R 是控制权重 (如果你觉得电机太吵/抖动，增大这个值)
R = 1

# ==========================================
# 4. 计算 LQR 增益 K
# ==========================================
# K 是反馈增益，S 是 Riccati 方程的解，E 是闭环极点
K, S, E = control.lqr(A, B, Q, R)

print("--- LQR 计算结果 ---")
print(f"反馈增益 K: \n{K}")
print(f"\n闭环极点 (确保实部都为负): \n{E}")

# ==========================================
# 5. 输出 C 语言伪代码，方便你直接填入单片机
# ==========================================
print("\n--- 实现参考 ---")
print(f"double base_effort = -({K[0,0]:.4f} * pos_error + {K[0,1]:.4f} * v_lqr_ + {K[0,2]:.4f} * pitch_lqr_ + {K[0,3]:.4f} * omega_lqr_);")

print(f"  k1: {K[0,0]:.4f}\n  k2: {K[0,1]:.4f} \n  k3: {K[0,2]:.4f} \n  k4: {K[0,3]:.4f}")